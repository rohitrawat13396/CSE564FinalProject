<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
    </head>
    <body>
        <div class="navbar-fixed">
            <nav>
              <div class="nav-wrapper white">
                <div id="airbnblogo" class="brand-logo">
                    <svg width="102" height="32" id="logo"><path d="M29.24 22.68c-.16-.39-.31-.8-.47-1.15l-.74-1.67-.03-.03c-2.2-4.8-4.55-9.68-7.04-14.48l-.1-.2c-.25-.47-.5-.99-.76-1.47-.32-.57-.63-1.18-1.14-1.76a5.3 5.3 0 00-8.2 0c-.47.58-.82 1.19-1.14 1.76-.25.52-.5 1.03-.76 1.5l-.1.2c-2.45 4.8-4.84 9.68-7.04 14.48l-.06.06c-.22.52-.48 1.06-.73 1.64-.16.35-.32.73-.48 1.15a6.8 6.8 0 007.2 9.23 8.38 8.38 0 003.18-1.1c1.3-.73 2.55-1.79 3.95-3.32 1.4 1.53 2.68 2.59 3.95 3.33A8.38 8.38 0 0022.75 32a6.79 6.79 0 006.75-5.83 5.94 5.94 0 00-.26-3.5zm-14.36 1.66c-1.72-2.2-2.84-4.22-3.22-5.95a5.2 5.2 0 01-.1-1.96c.07-.51.26-.96.52-1.34.6-.87 1.65-1.41 2.8-1.41a3.3 3.3 0 012.8 1.4c.26.4.45.84.51 1.35.1.58.06 1.25-.1 1.96-.38 1.7-1.5 3.74-3.21 5.95zm12.74 1.48a4.76 4.76 0 01-2.9 3.75c-.76.32-1.6.41-2.42.32-.8-.1-1.6-.36-2.42-.84a15.64 15.64 0 01-3.63-3.1c2.1-2.6 3.37-4.97 3.85-7.08.23-1 .26-1.9.16-2.73a5.53 5.53 0 00-.86-2.2 5.36 5.36 0 00-4.49-2.28c-1.85 0-3.5.86-4.5 2.27a5.18 5.18 0 00-.85 2.21c-.13.84-.1 1.77.16 2.73.48 2.11 1.78 4.51 3.85 7.1a14.33 14.33 0 01-3.63 3.12c-.83.48-1.62.73-2.42.83a4.76 4.76 0 01-5.32-4.07c-.1-.8-.03-1.6.29-2.5.1-.32.25-.64.41-1.02.22-.52.48-1.06.73-1.6l.04-.07c2.16-4.77 4.52-9.64 6.97-14.41l.1-.2c.25-.48.5-.99.76-1.47.26-.51.54-1 .9-1.4a3.32 3.32 0 015.09 0c.35.4.64.89.9 1.4.25.48.5 1 .76 1.47l.1.2c2.44 4.77 4.8 9.64 7 14.41l.03.03c.26.52.48 1.1.73 1.6.16.39.32.7.42 1.03.19.9.29 1.7.19 2.5zM41.54 24.12a5.02 5.02 0 01-3.95-1.83 6.55 6.55 0 01-1.6-4.48 6.96 6.96 0 011.66-4.58 5.3 5.3 0 014.08-1.86 4.3 4.3 0 013.7 1.92l.1-1.57h2.92V23.8h-2.93l-.1-1.76a4.52 4.52 0 01-3.88 2.08zm.76-2.88c.58 0 1.09-.16 1.57-.45.44-.32.8-.74 1.08-1.25.25-.51.38-1.12.38-1.8a3.42 3.42 0 00-1.47-3.04 2.95 2.95 0 00-3.12 0c-.44.32-.8.74-1.08 1.25a4.01 4.01 0 00-.38 1.8 3.42 3.42 0 001.47 3.04c.47.29.98.45 1.55.45zM53.45 8.46c0 .35-.06.67-.22.93-.16.25-.38.48-.67.64-.29.16-.6.22-.92.22-.32 0-.64-.06-.93-.22a1.84 1.84 0 01-.67-.64 1.82 1.82 0 01-.22-.93c0-.36.07-.68.22-.93.16-.3.39-.48.67-.64.29-.16.6-.23.93-.23a1.84 1.84 0 011.6.86 2 2 0 01.21.94zm-3.4 15.3V11.7h3.18v12.08h-3.19zm11.68-8.9v.04c-.15-.07-.35-.1-.5-.13-.2-.04-.36-.04-.55-.04-.89 0-1.56.26-2 .8-.48.55-.7 1.32-.7 2.31v5.93h-3.19V11.69h2.93l.1 1.83c.32-.64.7-1.12 1.24-1.48a3.1 3.1 0 011.81-.5c.23 0 .45.02.64.06.1.03.16.03.22.06v3.2zm1.28 8.9V6.74h3.18v6.5c.45-.58.96-1.03 1.6-1.38a5.02 5.02 0 016.08 1.31 6.55 6.55 0 011.6 4.49 6.96 6.96 0 01-1.66 4.58 5.3 5.3 0 01-4.08 1.86 4.3 4.3 0 01-3.7-1.92l-.1 1.57-2.92.03zm6.15-2.52c.57 0 1.08-.16 1.56-.45.44-.32.8-.74 1.08-1.25.26-.51.38-1.12.38-1.8 0-.67-.12-1.28-.38-1.79a3.75 3.75 0 00-1.08-1.25 2.95 2.95 0 00-3.12 0c-.45.32-.8.74-1.09 1.25a4.01 4.01 0 00-.38 1.8 3.42 3.42 0 001.47 3.04c.47.29.98.45 1.56.45zm7.51 2.53V11.69h2.93l.1 1.57a3.96 3.96 0 013.54-1.89 4.1 4.1 0 013.82 2.44c.35.76.54 1.7.54 2.75v7.24h-3.19v-6.82c0-.84-.19-1.5-.57-1.99-.38-.48-.9-.74-1.56-.74-.48 0-.9.1-1.27.32-.35.23-.64.52-.86.93a2.7 2.7 0 00-.32 1.35v6.92h-3.16zm12.52 0V6.73h3.19v6.5a4.67 4.67 0 013.73-1.89 5.02 5.02 0 013.95 1.83 6.57 6.57 0 011.59 4.48 6.95 6.95 0 01-1.66 4.58 5.3 5.3 0 01-4.08 1.86 4.3 4.3 0 01-3.7-1.92l-.09 1.57-2.93.03zm6.18-2.53c.58 0 1.09-.16 1.56-.45.45-.32.8-.74 1.09-1.25.25-.51.38-1.12.38-1.8a3.42 3.42 0 00-1.47-3.04 2.95 2.95 0 00-3.12 0c-.44.32-.8.74-1.08 1.25a3.63 3.63 0 00-.38 1.8 3.42 3.42 0 001.47 3.04c.47.29.95.45 1.55.45z"></path>
                    </svg>
                </div>
                <a href="#!" class="brand-logo center"><span id="logo">NYC Stay Recommender</a>
              </div>
            </nav>
          </div>
        
        </div>
        <div id="map"></div>
        <div id="pricescatterdiv"></div>
        <div id="pcascatterdiv"></div>
        <div id="barchartdiv"></div>
        
    </body>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
     
    <style>
        #logo {
            fill: #FF385C !important;
            color: #FF385C !important;
            font-weight: 1000;
            margin-left: 5px;
        }

        .boroughs {
            fill: rgb(222,235,247);
            stroke: #000;
            stroke-width: 0.5px;
        }

        circle {
        fill-opacity: .9;
        }

        circle.hidden {
        fill: #ccc !important;
        fill-opacity: 0.1;
        stroke-width: 0.2px;
        }

        #map {    
            position:absolute;
            top:60px;
            left:10px;
            width:500px;
            height: 500px; 
        }

        #pricescatterdiv {    
            position:absolute;
            top:60px;
            left:520px;
            height: 400px;
            width:600px;
        }
        
        #pcascatterdiv {    
            position:absolute;
            top:60px;
            left:950px;
            height: 400px;
            width:400px;
        }

        #barchartdiv {    
            position:absolute;
            top:345px;
            left:520px;
            height: 300px;
            width:800px;
        }

    </style>
    <script>

        var w = 500,
            h = 500;
        var margin = 20;
        var innerw = w - margin;
        var innerh = h - margin;
        var outergraph_translate_x = 60;
        var outergraph_translate_y = 30;
        var xScale;
        var yScale;
        var xScale2;
        var yScale2;
        var xScalebar;
        var yScalebar;
        var xAxis;
        var yAxis;
        var svgbarchart;
        var myColor;
        var grouped_bar_items;
        
        svg = d3.select("#map").append("svg").attr("width", w).attr("height", h).append("g")
                    .attr("id","outergraph")
                    .attr("transform", "translate(" + outergraph_translate_x + "," + outergraph_translate_y + ")");
        
        var brush = d3.brush()
            .on("start", brushstart)
            .on("brush", brushmove)
            .on("end", brushend);

        var brush2 = d3.brush()
            .on("start", brushstart2)
            .on("brush", brushmove2)
            .on("end", brushend);

        var brush3 = d3.brush()
            .on("start", brushstart3)
            .on("brush", brushmove3)
            .on("end", brushend);

        var brushCell;
        var brushCell2;
        var brushCell3;
        var inside_brush;

        function checkConditions(e,d,type){
            
            if(type==="map"){                    
                var map_check = true;
                var cx = projection([+d.longitude, +d.latitude])[0];
                            cy = projection([+d.longitude, +d.latitude])[1];
                if( !(e[0][0] > cx || cx > e[1][0]
                    || e[0][1] > cy || cy > e[1][1])){
                        inside_brush.push(+d.index);
                        map_check = false;
                    }
                    return map_check;
                
            }
            if(type === "pricescatter") {
            var scatter_price_zri_check = true;
            var cx = xScale(d[0]);
                               cy =  yScale(d[1]);
                if( !(e[0][0] > cx || cx > e[1][0]
                    || e[0][1] > cy || cy > e[1][1])){
                        inside_brush.push(+d[2]);
                        scatter_price_zri_check = false;
                    }
                return scatter_price_zri_check;
            
             }
            if(type === "pcascatter") {
            var pca_scatter_check = true;
            var cx = xScale2(d[0]);
                               cy =  yScale2(d[1]);
                if( !(e[0][0] > cx || cx > e[1][0]
                    || e[0][1] > cy || cy > e[1][1])){
                        inside_brush.push(+d[2]);
                        pca_scatter_check = false;
                    }
                return pca_scatter_check;
            
             }


         return true;   
        }

        // Clear the previously-active brush, if any.
        function brushstart(p) {
            console.log("inside brush start");
            inside_brush = [];
            // restore original bar
            // TO DO: Remove slicing from here once flask API is implemented
            orig_items = grouped_bar_items.slice(0,11)
            update(orig_items);
        if (brushCell !== this) {
            d3.select(brushCell).call(brush.move, null);
            
            brushCell = this;
            }
        }

        function brushstart2(p) {
            console.log("inside brush start");
            inside_brush = [];
            // TO DO: Remove slicing from here once flask API is implemented
            orig_items = grouped_bar_items.slice(0,11)
            update(orig_items);
        if (brushCell2 !== this) {
            d3.select(brushCell2).call(brush2.move, null);
            brushCell2 = this;
            }
        }

        function brushstart3(p) {
            console.log("inside brush start");
            inside_brush = [];
            // TO DO: Remove slicing from here once flask API is implemented
            orig_items = grouped_bar_items.slice(0,11)
            update(orig_items);
        if (brushCell3 !== this) {
            d3.select(brushCell3).call(brush3.move, null);
            brushCell3 = this;
            }
        }
 
        var brushed_area;
        // Highlight the selected circles.
        function brushmove(p) {
            inside_brush = []
            brushed_area = "map";
            var e = d3.brushSelection(this);
            d3.select("body").selectAll("#mapscatter").classed("hidden", function(d) {
                // to return default true, checkConditions should return false
                var to_return = checkConditions(e,d,"map");
                return !e? false: to_return;
            });
            var set_inside_brush = new Set(inside_brush)
            linkedBrush(brushed_area,set_inside_brush);
        }

        function brushmove2(p) {
            inside_brush = []
            var e = d3.brushSelection(this);
            brushed_area = "pricescatter"
            d3.select("body").selectAll("#pricescatter").classed("hidden", function(d) {
                var to_return = checkConditions(e,d,"pricescatter");
                return !e? false: to_return;
            });
            var set_inside_brush = new Set(inside_brush)
            linkedBrush(brushed_area,set_inside_brush);
        }

        function brushmove3(p) {
            inside_brush = []
            var e = d3.brushSelection(this);
            brushed_area = "pcascatter"
            d3.select("body").selectAll("#pcascatter").classed("hidden", function(d) {
                var to_return = checkConditions(e,d,"pcascatter");
                return !e? false: to_return;
            });
            var set_inside_brush = new Set(inside_brush)
            linkedBrush(brushed_area,set_inside_brush);
        }

        function linkedBrush(type,set_inside_brush){
            if(type === "map"){
                    d3.select("body").selectAll("#pricescatter").classed("hidden", function(d) {
                        if(set_inside_brush.has(+d[2])){
                        return false;
                        }
                        else{
                            return true;
                        }
                    });
                    d3.select("body").selectAll("#pcascatter").classed("hidden", function(d) {
                        if(set_inside_brush.has(+d[2])){
                        return false;
                        }
                        else{
                            return true;
                        }
                    });
            }
            if(type === "pricescatter"){
                d3.select("body").selectAll("#mapscatter").classed("hidden", function(d) {
                    if(set_inside_brush.has(+d.index)){
                        return false;
                        }
                        else{
                            return true;
                        }
                });
                d3.select("body").selectAll("#pcascatter").classed("hidden", function(d) {
                        if(set_inside_brush.has(+d[2])){
                        return false;
                        }
                        else{
                            return true;
                        }
                    });
            }
            if(type === "pcascatter"){
                d3.select("body").selectAll("#mapscatter").classed("hidden", function(d) {
                    if(set_inside_brush.has(+d.index)){
                        return false;
                        }
                        else{
                            return true;
                        }
                });
                d3.select("body").selectAll("#pricescatter").classed("hidden", function(d) {
                        if(set_inside_brush.has(+d[2])){
                        return false;
                        }
                        else{
                            return true;
                        }
                    });
            }

            // TO DO: FLASK API call here, result should go in random_items_to_update
            // Take input to API as set_inside_brush, which has the index of all the rows inside the brushed area
            const n = 12;
            const random_items_to_update = grouped_bar_items
            .map(x => ({ x, r: Math.random() }))
            .sort((a, b) => a.r - b.r)
            .map(a => a.x)
            .slice(0, n);
            
            update(random_items_to_update);

        }
        // If the brush is empty, select all circles.
        function brushend() {
        console.log("inside brush end");
        var e = d3.brushSelection(this);
        if (e === null) d3.select("body").selectAll(".hidden").classed("hidden", false);
        }

        var projection = d3.geoMercator() // mercator makes it easy to center on specific lat/long
            .scale(50000)
            .center([-73.644560,40.682308]); // long, lat of NYC

        var pathGenerator = d3.geoPath()
            .projection(projection);

        d3.json("nyc.geo.json", function(error, boroughs) {
            if (error) return console.error(error);
            //console.log(boroughs);
            svg.selectAll("path")
                .data(boroughs.features)
              .enter().append("path")
                .attr("class", "boroughs")
                .attr("d", pathGenerator);

            // With map made, load data and add it to the map
            // TO DO: Flask API call here, load data from flask
            // We need PC1 and PC2 columns in the dataset for PCA
            d3.csv('stratified_sampled_data.csv', function(error2, airbnbdata) {
                if (error2) return console.error(error2);
                var neighbourhood_groups = airbnbdata.map(function(d) { return d.neighbourhood_group; })
                var neighbourhoods = Array.from(new Set(neighbourhood_groups));
                myColor = d3.scaleOrdinal().domain(neighbourhoods).range(d3.schemeCategory10);

                 // TO DO: FLASK API call here, results of default API call should go in result
                 // keep grouped_bar_items = result, we need it to restore the array later
                // grouping zip codes default
                // result should look like this, for example [{group:Jan, value: 100},{group:Feb, value: 1000}]
                // for all 12 months until December 2019
                var result = [];
                airbnbdata.reduce(function(res, val) {
                if (!res[val.zipcodes]) {
                    res[val.zipcodes] = { group: val.zipcodes, value: 0 };
                    result.push(res[val.zipcodes])
                }
                res[val.zipcodes].value += +val.CMPLNT_NUM_count_sum;
                return res;
                }, {});

                grouped_bar_items = result;

                // TO DO: After implementing FLASK API call, remove slicing from here
                result = result.slice(0, 11);

                addPointsToMap(airbnbdata,neighbourhoods);
                drawScatterPlot(airbnbdata,"Price/Night","Rating","pricescatter");
                drawScatterPlot(airbnbdata,"PC1","PC2","pcascatter");
                drawBarChart(result);
                
            });

        });

        var addPointsToMap = function(airbnbdata,neighbourhoods) {
            var radiusScale = d3.scaleSqrt()
                // .domain([d3.extent(crimeData, function(crime) { return +crime.TOT; })])
                .domain([1,5])
                .range([2, 15]);

            drawLegend(neighbourhoods);
            all_circles = svg.selectAll("circle")
                .data(airbnbdata)
              .enter().append("circle")
                .attr("fill", function(d) { return myColor(d.neighbourhood_group) })
                .attr("cx", function(d) { return projection([+d.longitude, +d.latitude])[0]; })
                .attr("cy", function(d) { return projection([+d.longitude, +d.latitude])[1]; })
                .attr("id","mapscatter")
                .attr("idx",function(d){ return +d.index})
                .attr("r",  function(d) { return 2 });

            svg.append("g")
                .call(brush);
        };
        
        var drawScatterPlot = function(dataset,x_lab,y_lab,type){
        var x_label=x_lab,y_label=y_lab;

       
        var w = 400,
            h = 300;
        var margin = 70;
        var innerw = w - margin;
        var innerh = h - margin;
        var outergraph_translate_x = 40;
        var outergraph_translate_y = 10;
        
        if(type === "pricescatter"){
        final_ds = dataset.map(function(d) { return [+d.price,+d.review_scores_rating,+d.index,d.neighbourhood_group]; })
        }
        if(type === "pcascatter"){
        // TO DO: Flask API call, don't call the API here, just rename
        // Rename price_zscore to PC1 and crime_zscore to PC2
        final_ds = dataset.map(function(d) { return [+d.price_zscore,+d.crime_zscore,+d.index,d.neighbourhood_group]; })
        }
        var buffer = 2;
        // final_ds = dataset.original.circle.concat(dataset.stratified.circle,dataset.random.circle)
        x_lim = d3.extent(final_ds, d => d[0])
        y_lim = d3.extent(final_ds, d => d[1])

        if(type === "pricescatter"){
        xScale = d3.scaleLinear().range([0, innerw]).domain([x_lim[0]-buffer, x_lim[1]+buffer]);
        yScale = d3.scaleLinear().range([innerh, 0]).domain([y_lim[0]-buffer, y_lim[1]+buffer]);
        }
        if(type === "pcascatter"){
        xScale2 = d3.scaleLinear().range([0, innerw]).domain([x_lim[0]-buffer, x_lim[1]+buffer]);
        yScale2 = d3.scaleLinear().range([innerh, 0]).domain([y_lim[0]-buffer, y_lim[1]+buffer]);
        }
        // clearGraph();
        
        var svg2 = d3.select("#"+type+"div").append("svg").attr("width", w).attr("height", h)
                    .append("g")
                    .attr("id",type+"divid")
                    .attr("transform", "translate(" + outergraph_translate_x + "," + outergraph_translate_y + ")");
        
        var g = d3.select("#"+type+"divid")

        // Build X-Axis
        if(type === "pricescatter"){
        var x_axis_label = g.append("g")
            .attr("transform", "translate(0," + innerh + ")")
            .transition()
            .duration(500)
            .call(d3.axisBottom(xScale))
            .attr("font-weight", "bold");

        g.append("g")
            .transition()
            .duration(500)
            .call(d3.axisLeft(yScale))
            .attr("font-weight", "bold")
        }
        if(type === "pcascatter"){
            var x_axis_label = g.append("g")
            .attr("transform", "translate(0," + innerh + ")")
            .transition()
            .duration(500)
            .call(d3.axisBottom(xScale2))
            .attr("font-weight", "bold");
        
        g.append("g")
            .transition()
            .duration(500)
            .call(d3.axisLeft(yScale2))
            .attr("font-weight", "bold")
        }
        // Build Y-Axis
        
        // Draw X Axis label
        g.append("text")
            .transition()
            .duration(500)
            .attr("y", innerh + 40)
            .attr("x", innerw - 10)
            .attr("text-anchor", "end")
            .attr("font-weight", "bold")
            .text(x_label);

        // Draw Y Axis label
        g.append("text")
            .transition()
            .duration(500)
            .attr("transform", "rotate(-90)")
            .attr("dy", "-30px")
            .attr("text-anchor", "end")
            .attr("font-weight", "bold")
            .text(y_label);

        // drawLegend()

        g.append('g')
            .selectAll("circle")
            .data(final_ds)
            .enter()
            .append("circle")
            .transition()
            .duration(500)
            .attr("cx", function (d) { 
                if(type === "pricescatter"){
                    return xScale(d[0]); 
                }
                if(type === "pcascatter"){
                    return xScale2(d[0]); 
                }
            } )
            .attr("cy", function (d) { 
                if(type === "pricescatter"){
                    return yScale(d[1]); 
                }
                if(type === "pcascatter"){
                    return yScale2(d[1]); 
                }
            } )
            .attr("r", 2)
            .attr("id",type)
            .attr("idx",function(d){ return d[2]})
            .style("fill", function(d){ return myColor(d[3]);});
        
        if(type === "pricescatter"){
        svg2.append('g').call(brush2);
        }
        if(type === "pcascatter"){
        svg2.append('g').call(brush3);
        }
        };


        var drawBarChart = function(dataset){

            var data1 = dataset;

                var w = 800,
                    h = 300;
                var margin = 70;
                var innerw = w - margin;
                innerhbar = h - margin;
                var outergraph_translate_x = 60;
                var outergraph_translate_y = 10;

                svgbarchart = d3.select("#barchartdiv")
                    .append("svg").attr("width", w).attr("height", h).append("g")
                    .attr("id","outergraphbarchart")
                    .attr("transform", "translate(" + outergraph_translate_x + "," + outergraph_translate_y + ")");
      

                // Initialize the X axis
                xScalebar = d3.scaleBand()
                .range([ 0, innerw ])
                .padding(0.2);
                xAxis = svgbarchart.append("g")
                .attr("transform", "translate(0," + innerhbar + ")")

                // Initialize the Y axis
                yScalebar = d3.scaleLinear()
                .range([innerhbar, 0]);

                yAxis = svgbarchart.append("g")
                .attr("class", "myYaxis")

                svgbarchart.append("text")
                    .transition()
                    .duration(500)
                    .attr("y", innerhbar + 40)
                    .attr("x", innerw - 10)
                    .attr("text-anchor", "end")
                    .attr("font-weight", "bold")
                    .text("2019 months");

                // Draw Y Axis label
                svgbarchart.append("text")
                    .transition()
                    .duration(500)
                    .attr("transform", "rotate(-90)")
                    .attr("dy", "-50px")
                    .attr("text-anchor", "end")
                    .attr("font-weight", "bold")
                    .text("Number of Crimes");

                // Initialize the plot with the dataset passed
                update(data1)

        }

                // A function that create / update the plot for a given variable:
                function update(data) {
                // Update the X axis
                xScalebar.domain(data.map(function(d) { return d.group; }))
                xAxis.call(d3.axisBottom(xScalebar))

                // Update the Y axis
                yScalebar.domain([0, d3.max(data, function(d) { return d.value }) ]);
                yAxis.transition().duration(1000).call(d3.axisLeft(yScalebar));

                // Create the u variable
                var u = svgbarchart.selectAll("rect")
                    .data(data)

                u.enter()
                    .append("rect") // Add a new rect for each new elements
                    .merge(u) // get the already existing elements as well
                    .transition() // and apply changes to all of them
                    .duration(1000)
                    .attr("x", function(d) { return xScalebar(d.group); })
                    .attr("y", function(d) { return yScalebar(d.value); })
                    .attr("width", xScalebar.bandwidth())
                    .attr("height", function(d) { return innerhbar - yScalebar(d.value); })
                    .attr("fill", "#FF385C")

                // If less group in the new dataset, I delete the ones not in use anymore
                u
                    .exit()
                    .remove()
                }


        function drawLegend(neighbourhoods){
        
        console.log(neighbourhoods);
        var legend = d3.select("#outergraph").selectAll(".legend").raise()
            .data(neighbourhoods)
            .enter().append("g")
            .attr("class", "legend")
            .attr("transform", function(d, i) { return "translate(-520," + i * 20 + ")"; });
        
        legend.raise().append("rect")
            .attr("x", innerw - 18)
            .attr("width", 18)
            .attr("height", 18)
            .style("fill", function(d){return myColor(d);});

        legend.append("text")
            .attr("x", innerw + 10)
            .attr("y", 9)
            .attr("dy", ".35em")
            .style("text-anchor", "start")
            .text(function(d) { return d; })
            .style("stroke","black");
    
    };
        
    </script>
</html>